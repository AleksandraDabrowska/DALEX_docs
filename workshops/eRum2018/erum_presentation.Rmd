---
title: "Prediction understanding"
author: "Mateusz Staniak"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE)
```


## Outline

1. Intro

2. Predictions breakdown
  
   * breakDown package
   
   * Shapley values
   
3. Local approximations

   * LIVE
   
   * LIME
   
4. Summary

# Introduction

## Why explain a single prediction?

(Bird's-eye view)

![](ilustracje_erum/bird.jpg)
  
  * when important decision are made based on ML model, it needs to be **trustworthy**
  
  * trust comes from **understanding**

  * the demand for interpretable algorithms is growing
    (see: _Weapons of math destruction_, Facebook feed controversies etc.)
  
(Worm-eye view)

![](ilustracje_erum/worm.jpg)

  * this demand is transfered into legal regulations (see: RODO)
  
=>  more and more institutions have to explain model predictions
  (debt collection, loans ...)
  
  * understanding models helps improve them
  
<!-- wskazac autorow / publikacje na temat pojedynczych predykcji -->
  
## Which predictions need explanation?

  1. Every prediction the client (or the boss) wants to understand
  
  2. Predictions that seem suspicious
     
     * How to spot them?
     
     * How to explain them?
     
  **=> model performance**
  
  **=> model diagnostics**
  
## Model diagnostics: example data

```{r data}
library(tidyverse)
library(randomForest)
load("./rda_files/houses.rda")
houses
hrf <- randomForest(sqm_price ~., data = houses)
```

## Model diagnostics: predicted vs observed values

```{r pred_obs, echo = F}
ggplot(tibble(x = houses$sqm_price, y = predict(hrf)), aes(x, y)) +
  geom_point() +
  geom_abline(slope = 1, intercept = 0, size = 1.2, color = "blue") +
  theme_bw() +
  xlab("True prices") +
  ylab("Fitted prices")
```

  * Points on the plot should be close to the `y = x` line,
  
  * Questions:
    
    - is there a pattern? (For example: does the devation from true value grow as true value grows?)
    
    - are there any points especially far from the line (meaning: points with large residuals)?
    
  * More diagnostic tools: `auditor` package
    
## Model performance

```{r performance}
library(DALEX)
rf_explainer <- explain(hrf, data = houses, y = houses$sqm_price)
rf_perf <- model_performance(rf_explainer)
plot(rf_perf, geom = "boxplot")
```

  * shortly summarizes the distribution of the absolute value of residuals
  
  * red dot is the root mean square error
  
  * we can put boxplots for several models on the same plot (simply by passing the as arguments to `plot`) to compare models
  
  * boxplots help discover outliers
  
  
## Single prediction explanation

  * Once we identified predictions we want to explain, we need tools that will help us!
  
  * Methods:
  
    - LIME
    
    - Shapley values
    
    - Break Down
    
    - LIVE
    
  * Two main ideas:
   
    - Attribute scores to explanatory variables according to their influence on the prediction (**contributions**)
    
    - Fit a model locally around an observation and investigate it
    
    - NOTE: both approaches lead to local feature importance
    
  * Contributions: Shapley values and Break Down
  
  * Local models: LIME and LIVE
  
# Prediction breakdown

## Break Down

  * General idea
  
  ![](ilustracje_erum/breakdown_intuition.png)
  
  * Another approach to finding *additive* feature contributions
  
  * Contributions are assigned in a greedy manner
  
  * Waterfall plots as a visual tool

**=> more intuitive interpretation**

### Example

  * Break Down for linear models

```{r breakdown}
linear_model <- lm(sqm_price ~., data = houses)
lm_explainer <- DALEX::explain(linear_model, data = houses, y = houses$sqm_price)
breakdown_linear <- single_prediction(lm_explainer, houses[4036, -3])
plot(breakdown_linear)
```
  
    - Contributions are scaled, so they do not depend on the scale of the data (insensitive to location/scale change)
  
    - We can see actual contributions, not just the weights (as in LIME plots)

  * Model-agnostic Break Down
  
```{r breakdown2}
breakdown_explanation <- single_prediction(rf_explainer, houses[4036, -3])
plot(breakdown_explanation)
```

  * We can see how important District and Year are in this random forest prediction

  
## But isn't it enough to calculate feature importance?
  
```{r global_feature_importance}
global_feat_imp <- DALEX::variable_importance(rf_explainer)
plot(global_feat_imp)
```


  * No. Particular instances can be influenced the most by different features,
  not necessarily the ones that are most important globally.
  

## Shapley values

  * General idea

    - The goal is a decomposition of prediction into a **sum** of scores related to (simplified) features.
  
    - The problem is solved using game theory: _Shapley values_. 
  Variables are _players_ who contribute to the outcome - the prediction - and we try to _pay_ them accordingly to their contributions.
  
  - This approach unifies several methods (including `LIME`).
  
  * Some details

    - Exact methods exist for linear models and tree ensemble methods.
  In other cases, approximations are needed.
  
    - The classic way: sample permutations of variables, then average contributions.
  
    - The better way: approximation based on LIME and Shapley values for regression.

  * This method has good theoretical properties, but will not produce sparse explanations

### Example

```{r shapley}
library(shapleyr)
library(mlr)
house_task <- makeRegrTask(data = houses, target = "sqm_price")
house_rf_mlr <- train("regr.randomForest", house_task)

shapley_explanation <- shapley(4036,
                               task = house_task,
                               model = house_rf_mlr)
class(shapley_explanation) <- c("shapley.singleValue", "list")
gather(shapley_explanation$values, "feature", "shapley.score")
plot(shapley_explanation)
```

  * **0** is the mean of all predictions
  
  * the **black dot** is the prediction we are explaining
  
  * values and the plot describe how we move from the global mean of predictions to this particular predictions
  
  * most important features are the ones that help move the most

  
## Time to practice!

First set of exercises goes here


# Local approximations 

## LIVE (Local Interpretable Visual Explanations)

  * General idea
  
    - Modification of `LIME` for tabular data and regression problems with emphasis on model visualization.
  
    - Similar observations for _fake_ dataset are sampled from empirical distributions.
    
    - Variable selection is possible (LASSO, then explanation model is fitted to selected features).
    
  * More details
  
    - Two methods of creating the new dataset are available: by permuting each variable and by changing one feature per observations
    
    - We can control which variables are allowed to vary through `fixed` variable argument to `sample_locally` (keeping date/factor/correlated variables unchanged)
    
### Example

```{r live}
library(live)
library(mlr)
new_dataset <- sample_locally2(data = houses,
                               explained_instance = houses[4036, ],
                               explained_var = "sqm_price",
                               size = 1000)
with_predictions <- add_predictions2(new_dataset, hrf)
live_explanation <- fit_explanation2(with_predictions, "regr.lm")
live_explanation
```
    
  Aktualnie standaryzacja zmiennych jest niepotrzebnie w sample_locally, jak to zmienię, forestplot będzie lepiej wyglądał, bo będzie po standaryzacji
    
  * Default method of sampling is _live_, default explanation model is linear regression and distance is measured (weights are assigned) by gaussian kernel.   

  * Plot local model structure: forest plot
  
```{r forest}
plot_explanation2(live_explanation, "forest")
```

  * Plot local variable contributions: waterfall plot (Break Down)
  
```{r waterfall}
plot_explanation2(live_explanation, "waterfall")
```


## LIME (Locally Interpretable Model-agnostic Explanations)

  * General idea
  
  ![](ilustracje_erum/lime_intuition.png)
  
  * Some details:
  
    - Gaussian sampling for tabular, uniform sampling from interpretable inputs for image/text.
  
  - Scores for new observation are weighted by the distance from original observation.
  
  - Variable selection is usually based on ridge/lasso regression.
  
  - Weights are assigned to interpretable inputs to decide if they _vote_ for or against a given label.
  
  * Note: method depends on many hyperparameters
  
### Example  

```{r lime}
library(lime)
explained_prediction <- houses[4036, ]
lime_explainer <- lime(houses,
                       model = house_rf_mlr)
lime_explanation <- lime::explain(houses[4036, ],
                                  explainer = lime_explainer,
                                  n_features = 5)
```


  *  weights from ridge regression are on the plot (NOT weights multiplied by actual feature values)
  
  * positive weights are _for_, negative weights are _against_
  

## Acknowledgement

Podziekowanie dla UWr...

## Time to practice!

Third set of exercises goes here
